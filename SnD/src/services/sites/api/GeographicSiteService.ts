/**
 * Geographic Site
 * ## TMF API Reference : TMF 674 - Place - Geographic Site Management  ### Release : 19.5 - November 2019  This API covers the operations to manage (create, read, delete) sites that can be associated to a customer, an account, a service delivery or other entities. It defines a Site as a convenience class that allows to easily refer to places important to other entities, where a geographic place is the entity that can answer the question “where?”, allowing to determine where things are in relation to the earth's surface, and can be represented either in a textual structured way (geographic address) or as a geometry referred to a spatial reference system (geographic location).  ### Resources - GeographicSite - Hub  ### Operations Geographic Site API performs the following operations : - Retrieve a geographic site or a collection of geographic sites - Create a new site - Update a geographic site - Delete a geographic site - Notify events on geographic site  Copyright © TM Forum 2019. All Rights Reserved
 *
 * OpenAPI spec version: 4.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */
/* eslint-disable no-param-reassign */

import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import IHttpClient from '../../IHttpClient';
import { IAPIConfiguration } from '../../IAPIConfiguration';
import { Headers } from '../../Headers';
import HttpResponse from '../../HttpResponse';
import IFilter from '../../../types/IFilter';
import { GeographicSite } from '../model/geographicSite';
import { GeographicSiteCreate } from '../model/geographicSiteCreate';
import MasterConfigService from '../../master/api/MasterConfigService';
import HttpClient from '../../HttpClient';

export default class GeographicSiteService {
    APIConfiguration: IAPIConfiguration;

    httpClient: IHttpClient;

    masterService = new MasterConfigService();

    urlFromLocalStorage = localStorage.getItem('GEOGRAPHIC_SITE');

    constructor() {
        this.APIConfiguration = {
            basePath: ''
        };
        try {
            if (this.urlFromLocalStorage)
                this.APIConfiguration.basePath = this.urlFromLocalStorage;
        } catch (e) {
            console.log('error while fetching geographic site url', e);
        }
        this.httpClient = new HttpClient();
    }

    /**
     * Creates a GeographicSite
     * This operation creates a GeographicSite entity.
     * @param geographicSite The GeographicSite to be created
     
     */
    public createGeographicSiteAndGetBody(
        geographicSite: GeographicSiteCreate,
        observe?: 'body',
        headers?: Headers
    ): Observable<GeographicSite> {
        return this.createGeographicSite(geographicSite, observe, headers);
    }

    public createGeographicSiteAndGetResponse(
        geographicSite: GeographicSiteCreate,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<GeographicSite>> {
        return this.createGeographicSite(geographicSite, observe, headers);
    }

    public createGeographicSite(
        geographicSite: GeographicSiteCreate,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!geographicSite) {
            throw new Error(
                'Required parameter geographicSite was null or undefined when calling createGeographicSite.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<GeographicSite>> =
            this.httpClient.post(
                `${this.APIConfiguration.basePath}/geographicSite`,
                geographicSite as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Deletes a GeographicSite
     * This operation deletes a GeographicSite entity.
     * @param id Identifier of the GeographicSite
     
     */
    public deleteGeographicSite(
        id: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<any>;

    public deleteGeographicSite(
        id: string,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<any>>;

    public deleteGeographicSite(
        id: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling deleteGeographicSite.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(
            `${this.APIConfiguration.basePath
            }/geographicSite/${encodeURIComponent(String(id))}` as any,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * List or find GeographicSite objects
     * This operation list or find GeographicSite entities
     * @param fields Comma-separated properties to be provided in response
     * @param offset Requested index for start of resources to be provided in response
     * @param limit Requested number of resources to be provided in response
     
     */
    public listGeographicSiteAndGetBody(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'body',
        headers?: Headers
    ): Observable<Array<GeographicSite>> {
        return this.listGeographicSite(fields, offset, limit, observe, headers);
    }

    public listGeographicSiteAndGetResponse(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'response',
        headers?: Headers,
        filters?: any
    ): Observable<HttpResponse<Array<GeographicSite>>> {
        return this.listGeographicSite(
            fields,
            offset,
            limit,
            observe,
            headers,
            filters
        );
    }

    public listGeographicSite(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filter?: any
    ): Observable<any> {
        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }
        if (filter != undefined) {
            filter.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}${filter.operator === 'eq' ? '*=' : filter.operator
                    }${encodeURIComponent(String(filter.value))}`
                );
            });
        }
        if (offset !== undefined) {
            queryParameters.push(
                `offset=${encodeURIComponent(String(offset))}`
            );
        }
        if (limit !== undefined) {
            queryParameters.push(`limit=${encodeURIComponent(String(limit))}`);
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<GeographicSite>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/geographicSite?${queryParameters.join('&')}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public listGeographicSiteWithoutAndGetBody(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'body',
        headers?: Headers
    ): Observable<Array<GeographicSite>> {
        return this.listGeographicSiteWithoutRegion(
            fields,
            offset,
            limit,
            observe,
            headers
        );
    }

    public listGeographicSiteWithoutRegionAndGetResponse(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'response',
        headers?: Headers,
        filters?: any
    ): Observable<HttpResponse<Array<GeographicSite>>> {
        return this.listGeographicSiteWithoutRegion(
            fields,
            offset,
            limit,
            observe,
            headers,
            filters
        );
    }

    public listGeographicSiteWithoutRegion(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filter?: any
    ): Observable<any> {
        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }
        if (filter != undefined) {
            filter.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}${filter.operator === 'eq' ? '*=' : filter.operator
                    }${encodeURIComponent(String(filter.value))}`
                );
            });
        }
        if (offset !== undefined) {
            queryParameters.push(
                `offset=${encodeURIComponent(String(offset))}`
            );
        }
        if (limit !== undefined) {
            queryParameters.push(`limit=${encodeURIComponent(String(limit))}`);
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<GeographicSite>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/geographicSite?${queryParameters.join(
                    '&'
                )}&type=operator warehouse,shops,dealer warehouse,retailer location,sales terminal` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public listGeographicSiteRegionAndGetResponse(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'response',
        headers?: Headers,
        filters?: any
    ): Observable<HttpResponse<Array<GeographicSite>>> {
        return this.listGeographicSiteRegion(
            fields,
            offset,
            limit,
            observe,
            headers,
            filters
        );
    }

    public listGeographicSiteRegion(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filter?: any
    ): Observable<any> {
        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }
        if (filter != undefined) {
            filter.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}${filter.operator === 'eq' ? '*=' : filter.operator
                    }${encodeURIComponent(String(filter.value))}`
                );
            });
        }
        if (offset !== undefined) {
            queryParameters.push(
                `offset=${encodeURIComponent(String(offset))}`
            );
        }
        if (limit !== undefined) {
            queryParameters.push(`limit=${encodeURIComponent(String(limit))}`);
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<GeographicSite>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/geographicSite?${queryParameters.join(
                    '&'
                )}&type=region,cluster,sales area,survey area,route` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Updates partially a GeographicSite
     * This operation updates partially a GeographicSite entity.
     * @param id Identifier of the GeographicSite
     * @param geographicSite The GeographicSite to be updated
     
     */
    public patchGeographicSiteAndGetBody(
        id: string,
        geographicSite: GeographicSite,
        observe?: 'body',
        headers?: Headers
    ): Observable<GeographicSite> {
        return this.patchGeographicSite(id, geographicSite, observe, headers);
    }

    public patchGeographicSiteAndGetResponse(
        id: string,
        geographicSite: GeographicSite,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<GeographicSite>> {
        return this.patchGeographicSite(id, geographicSite, observe, headers);
    }

    public patchGeographicSite(
        id: string,
        geographicSite: GeographicSite,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling patchGeographicSite.'
            );
        }

        if (!geographicSite) {
            throw new Error(
                'Required parameter geographicSite was null or undefined when calling patchGeographicSite.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<GeographicSite>> =
            this.httpClient.patch(
                `${this.APIConfiguration.basePath
                }/geographicSite/${encodeURIComponent(String(id))}`,
                geographicSite as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Retrieves a GeographicSite by ID
     * This operation retrieves a GeographicSite entity. Attribute selection is enabled for all first level attributes.
     * @param id Identifier of the GeographicSite
     * @param fields Comma-separated properties to provide in response
     
     */
    public retrieveGeographicSiteAndGetBody(
        id: string,
        fields?: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<GeographicSite> {
        return this.retrieveGeographicSite(id, fields, observe, headers);
    }

    public retrieveGeographicSiteAndGetResponse(
        id: string,
        fields?: string,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<GeographicSite>> {
        {
            return this.retrieveGeographicSite(id, fields, observe, headers);
        }
    }

    public retrieveGeographicSite(
        id: string,
        fields?: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling retrieveGeographicSite.'
            );
        }

        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<GeographicSite>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/geographicSite/${encodeURIComponent(
                    String(id)
                )}?${queryParameters.join('&')}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }
}
