/**
 * Cash Register Management API
 * APIs to manage Cash Register
 *
 * OpenAPI spec version: 1.6.10
 * Contact: yagyawal.thakur@comviva.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import IHttpClient from '../../IHttpClient';
import { IAPIConfiguration } from '../../IAPIConfiguration';
import { Headers } from '../../Headers';
import HttpResponse from '../../HttpResponse';
import { Register } from '../model/register';
import MasterConfigService from '../../../services/master/api/MasterConfigService';
import HttpClient from '../../../services/HttpClient';
import IFilter from 'src/types/IFilter';

export default class RegisterService {
    masterService = new MasterConfigService();

    APIConfiguration: IAPIConfiguration;
    httpClient: IHttpClient;

    constructor() {
        this.APIConfiguration = {
            basePath: ''
        };
        try {
            this.masterService
                .getServiceUrl('CASH_REGISTER')
                .subscribe((url) => (this.APIConfiguration.basePath = url));
        } catch (e) {
            console.log('error while fetching cash register url', e);
        }
        this.httpClient = new HttpClient();
    }

    /**
     * Creates a new Register
     * This API creates a new register in system. &lt;/br&gt; This is an asyncronous API. It will provide a corelationId and monitor URL in the response body on successful submission of the task.&lt;/br&gt; The monitor URL can be used to track the progress of this async process.&lt;/br&gt; A callback API will be invoked (on completion/failure of the task) to notify the client about the outcome.
     * @param register 
     
     */
    public createRegister(
        register: Register,
        observe?: 'body',
        headers?: Headers
    ): Observable<Register>;
    public createRegister(
        register: Register,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<Register>>;
    public createRegister(
        register: Register,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!register) {
            throw new Error(
                'Required parameter register was null or undefined when calling createRegister.'
            );
        }

        headers['Accept'] = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Register>> =
            this.httpClient.post(
                `${this.APIConfiguration.basePath}/registers`,
                register as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Deletes register associated with this id.
     * This operation  &lt;/br&gt; a) Deletes register associated with this id.&lt;/br&gt;
     * @param id The id of the Register
     
     */
    public deleteRegister(
        id: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<Register>;
    public deleteRegister(
        id: string,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<Register>>;
    public deleteRegister(
        id: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling deleteRegister.'
            );
        }

        headers['Accept'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Register>> =
            this.httpClient.delete(
                `${this.APIConfiguration.basePath
                }/registers/${encodeURIComponent(
                    String(id)
                )}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Returns a register associatedwith this id.
     * 
     * @param id Identifier of the Register
     
     */
    public getRegister(
        id: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<Array<Register>>;
    public getRegister(
        id: string,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<Array<Register>>>;
    public getRegister(
        id: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling getRegister.'
            );
        }

        headers['Accept'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<Register>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/registers/${encodeURIComponent(
                    String(id)
                )}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Lists or finds Registers
     * List or find Registers. &lt;/p&gt; &lt;/br&gt;This API Supports &lt;/br&gt;a) Pagination using limit and offset query parameters &lt;/br&gt;b) Projection using fields query parameter &lt;/br&gt;c) Filter using query parameters e.g.&lt;/br&gt; http://...?registeredMobileNumber&#x3D;9999999999 &lt;/br&gt;http://...?firstName*&#x3D;&lt;RegEx&gt; etc
     * @param fields Comma-separated properties to be provided in response
     * @param offset Requested index for start of resources to be provided in response
     * @param limit Requested number of resources to be provided in response
     
     */
    public listRegisters(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'body',
        headers?: Headers,
        filter?: any
    ): Observable<Array<Register>>;
    public listRegisters(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'response',
        headers?: Headers,
        filter?: any
    ): Observable<HttpResponse<Array<Register>>>;
    public listRegisters(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filter?: any
    ): Observable<any> {
        let queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                'fields=' + encodeURIComponent(String(fields))
            );
        }
        if (filter != undefined) {
            filter.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}${filter.operator === 'eq' ? '*=' : filter.operator
                    }${encodeURIComponent(String(filter.value))}`
                );
            });
        }
        if (offset !== undefined) {
            queryParameters.push(
                'offset=' + encodeURIComponent(String(offset))
            );
        }
        if (limit !== undefined) {
            queryParameters.push('limit=' + encodeURIComponent(String(limit)));
        }

        headers['Accept'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<Register>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/registers?sort=-registerDate&${queryParameters.join(
                    '&'
                )}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Updates the Register associated with this id.
     * Updates the Register associated with this id.
     * @param id Identifier of the Register
     * @param register 
     
     */
    public updateRegister(
        id: string,
        register: Register,
        observe?: 'body',
        headers?: Headers
    ): Observable<Register>;
    public updateRegister(
        id: string,
        register: Register,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<Register>>;
    public updateRegister(
        id: string,
        register: Register,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling updateRegister.'
            );
        }

        if (!register) {
            throw new Error(
                'Required parameter register was null or undefined when calling updateRegister.'
            );
        }

        headers['Accept'] = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Register>> =
            this.httpClient.patch(
                `${this.APIConfiguration.basePath
                }/registers/${encodeURIComponent(
                    String(id)
                )}`,
                register as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public makeTransaction(
        payload: any,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {

        headers['Accept'] = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Register>> =
            this.httpClient.post(
                `${this.APIConfiguration.basePath
                }/registers/registerTransaction`,
                payload as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public updateTransaction(
        id: string,
        payload: any,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
       
        headers['Accept'] = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Register>> =
            this.httpClient.patch(
                `${this.APIConfiguration.basePath
                }/registers/registerTransaction/${encodeURIComponent(
                    String(id)
                )}`,
                payload as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public listTransactions(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'body',
        headers?: Headers,
        filter?: any
    ): Observable<Array<any>>;
    public listTransactions(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'response',
        headers?: Headers,
        filter?: any
    ): Observable<HttpResponse<Array<any>>>;
    public listTransactions(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filter?: any
    ): Observable<any> {
        let queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                'fields=' + encodeURIComponent(String(fields))
            );
        }
        if (filter != undefined) {
            filter.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}${filter.operator === 'eq' ? '*=' : filter.operator
                    }${encodeURIComponent(String(filter.value))}`
                );
            });
        }
        if (offset !== undefined) {
            queryParameters.push(
                'offset=' + encodeURIComponent(String(offset))
            );
        }
        if (limit !== undefined) {
            queryParameters.push('limit=' + encodeURIComponent(String(limit)));
        }

        headers['Accept'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<Register>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/registers/registerTransaction?sort=-transactionTime&${queryParameters.join(
                    '&'
                )}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public getLedger(
        register: Register,
        observe?: 'body',
        headers?: Headers
    ): Observable<Array<any>>;
    public getLedger(
        register: Register,
        observe?: 'body',
        headers?: Headers
    ): Observable<HttpResponse<Array<any>>>;
    public getLedger(
        register: Register,
        observe: 'body',
        headers: Headers = {}
    ): Observable<any> {

        headers['Accept'] = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';


        const response: Observable<HttpResponse<Register>> =
            this.httpClient.post(
                `${this.APIConfiguration.basePath}/registers/ledger`,
                register as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }
}
