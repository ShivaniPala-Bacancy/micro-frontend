/**
 * Quote
 * **TMF API Reference : TMF 648 - Quote Management**  **Release : 19.0 - June 2019**  The Quote API provides a standardized mechanism for placing a quote with all of the necessary parameters. The API consists of a simple set of operations that interact with CRM/Quote/Pricing Negotiation systems in a consistent manner. A Quote is created based on product offering(s) that is(are) defined in a catalog. The quote identifies the product or set of products that are available to a customer for pricing request, and includes product characteristics.  The Quote references the product offer(s) which (future) customer request pricing. Quote resource features authorization subclass to manage special pricing UC requiring authorization tracking management  **Quote resource** A Quote can be used to request pricing between a customer and a service provider or between a service provider and a partner and vice versa. Main quote attributes are its identifier, state, priority, related dates (requested, expected, valid, completion, etc.), related parties and quote items. Main Quote Items attributes are the discribed offering and product characteristics with the related action to be performed (e.g. add, change or delete the products), location information, and product characteristics.  Quote API performs the following operations on Quote :  - Retrieval of a quote or a collection of quotes depending on filter criteria - Partial update of a quote (including updating rules) - Creation of a quote (including default values and creation rules) - Deletion of quote (for administration purposes) - Notification of events on quote.  Copyright Â© TM Forum 2019. All Rights Reserved
 *
 * OpenAPI spec version: 4.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Observable} from 'rxjs';
import {map} from 'rxjs/operators';
import IFilter from 'src/types/IFilter';
import {Headers} from '../../Headers';
import HttpClient from '../../HttpClient';
import HttpResponse from '../../HttpResponse';
import {IAPIConfiguration} from '../../IAPIConfiguration';
import IHttpClient from '../../IHttpClient';
import MasterConfigService from '../../master/api/MasterConfigService';
import {Quote} from '../model/quote';

/* eslint-disable no-param-reassign */
export default class QuoteService {
    masterService = new MasterConfigService();

    APIConfiguration: IAPIConfiguration;

    httpClient: IHttpClient;

    constructor() {
        this.APIConfiguration = {
            basePath: ''
        };
        try {
            this.masterService
                .getServiceUrl('QUOTA_MANAGEMENT')
                .subscribe((url) => (this.APIConfiguration.basePath = url));
        } catch (e) {
            console.log('error while fetching quota management url', e);
        }
        this.httpClient = new HttpClient();
    }

    /**
     * Creates a Quote
     * This operation creates a Quote entity.
     * @param quote The Quote to be created
     
     */
    public createQuote(
        quote: Quote,
        observe?: 'body',
        headers?: Headers
    ): Observable<Quote>;

    public createQuote(
        quote: Quote,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<Quote>>;

    public createQuote(
        quote: Quote,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!quote) {
            throw new Error(
                'Required parameter quote was null or undefined when calling createQuote.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Quote>> = this.httpClient.post(
            `${this.APIConfiguration.basePath}`,
            quote as any,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public createListQuote(
        quote: any,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!quote) {
            throw new Error(
                'Required parameter quote was null or undefined when calling createQuote.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';
        const response: Observable<HttpResponse<any>> = this.httpClient.post(
            `${this.APIConfiguration.basePath}`,
            quote,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Deletes a Quote
     * This operation deletes a Quote entity.
     * @param id Identifier of the Quote
     
     */
    public deleteQuote(
        id: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<any>;

    public deleteQuote(
        id: string,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<any>>;

    public deleteQuote(
        id: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling deleteQuote.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(
            `${this.APIConfiguration.basePath}/${encodeURIComponent(
                String(id)
            )}` as any,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * List or find Quote objects
     * This operation list or find Quote entities
     * @param fields Comma-separated properties to be provided in response
     * @param offset Requested index for start of resources to be provided in response
     * @param limit Requested number of resources to be provided in response
     
     */
    public listQuoteAndGetBody(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'body',
        headers?: Headers
    ): Observable<HttpResponse<Array<Quote>>> {
        return this.listQuote(fields, offset, limit, observe, headers);
    }

    public listQuoteAndGetResponse(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<Array<Quote>>> {
        return this.listQuote(fields, offset, limit, observe, headers);
    }

    public listQuote(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filters?: IFilter[]
    ): Observable<any> {
        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }
        if (offset !== undefined) {
            queryParameters.push(
                `offset=${encodeURIComponent(String(offset))}`
            );
        }
        if (limit !== undefined) {
            queryParameters.push(`limit=${encodeURIComponent(String(limit))}`);
        }
        if (filters !== undefined) {
            filters.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}${
                        filter.operator === 'eq' ? '*=' : filter.operator
                    }${encodeURIComponent(String(filter.value))}`
                );
            });
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<Quote>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath}?${queryParameters.join(
                    '&'
                )}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Updates partially a Quote
     * This operation updates partially a Quote entity.
     * @param id Identifier of the Quote
     * @param quote The Quote to be updated
     
     */
    public patchQuote(
        id: string,
        quote: Quote,
        observe?: 'body',
        headers?: Headers
    ): Observable<Quote>;

    public patchQuote(
        id: string,
        quote: Quote,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<Quote>>;

    public patchQuote(
        id: string,
        quote: Quote,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling patchQuote.'
            );
        }

        if (!quote) {
            throw new Error(
                'Required parameter quote was null or undefined when calling patchQuote.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Quote>> = this.httpClient.patch(
            `${this.APIConfiguration.basePath}/${encodeURIComponent(
                String(id)
            )}`,
            quote as any,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Retrieves a Quote by ID
     * This operation retrieves a Quote entity. Attribute selection is enabled for all first level attributes.
     * @param id Identifier of the Quote
     * @param fields Comma-separated properties to provide in response
     
     */
    public retrieveQuote(
        id: string,
        fields?: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<Quote>;

    public retrieveQuote(
        id: string,
        fields?: string,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<Quote>>;

    public retrieveQuote(
        id: string,
        fields?: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling retrieveQuote.'
            );
        }

        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Quote>> = this.httpClient.get(
            `${this.APIConfiguration.basePath}/quote/${encodeURIComponent(
                String(id)
            )}?${queryParameters.join('&')}` as any,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }
}
