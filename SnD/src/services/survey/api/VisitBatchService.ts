/**
 *
 *
 *
 *
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Observable} from 'rxjs';
import {map} from 'rxjs/operators';
import IHttpClient from '../../IHttpClient';
import {IAPIConfiguration} from '../../IAPIConfiguration';
import {Headers} from '../../Headers';
import HttpResponse from '../../HttpResponse';
import HttpClient from '../../HttpClient';
import MasterConfigService from '../../master/api/MasterConfigService';
import {VisitBatch} from '../model/VisitBatch';
import IFilter from '../../../types/IFilter';
import {Zones} from '../model/VisitBatch';

/* eslint-disable no-param-reassign */

export default class StockNormService {
    APIConfiguration: IAPIConfiguration;

    masterService = new MasterConfigService();

    httpClient: IHttpClient;

    constructor() {
        this.APIConfiguration = {
            basePath: '',
            geographicSiteUrl: ''
        };
        try {
            this.masterService
                .getServiceUrl('VISIT_URL')
                .subscribe((url) => (this.APIConfiguration.basePath = url));
            this.masterService
                .getServiceUrl('GEOGRAPHIC_SITE')
                .subscribe(
                    (url) => (this.APIConfiguration.geographicSiteUrl = url)
                );
        } catch (e) {
            console.log('error while fetching visit url', e);
        }
        this.httpClient = new HttpClient();
    }

    /**
     * Get customer information for a given accountID
     * Get customer information for a given accountID
     * @param serviceID Get customer information for a given accountID
     @param queryString
     @param headers
     */

    public getVisitBatch(
        queryString: string,
        headers: Headers = {}
    ): Observable<any> {
        if (!queryString) {
            throw new Error(
                'Required parameter limit and offset was null or undefined when calling getInventoryDetails.'
            );
        }
        headers.Accept = 'application/json;charset=utf-8';
        headers['x-auth-token'] =
            'VQ/ZK9+z2gzgTOm1ZnMyn0Ev6byXWPqWgsj1TrbN74c=';
        const response: Observable<HttpResponse<VisitBatch>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath}/${queryString}`,
                headers
            );
        return response.pipe(map((d) => d.response));
    }

    public postVisitBatches(
        body: VisitBatch,
        headers: Headers = {}
    ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createInventory.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['x-auth-token'] =
            'VQ/ZK9+z2gzgTOm1ZnMyn0Ev6byXWPqWgsj1TrbN74c=';
        const response: Observable<HttpResponse<VisitBatch>> =
            this.httpClient.post(
                `${this.APIConfiguration.basePath}/visits/batches`,
                body,
                headers
            );
        return response.pipe(map((d) => d.response));
    }

    /**
     * Deletes a stock Norm
     * This operation deletes a Stock Norms entity.
     * @param id Identifier of the Stock Norm
     */

    deleteVisitBatches(
        id: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling delete StockNorms.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(
            `${this.APIConfiguration.basePath}/visits/batches/${id}`,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Updates partially an Inventory
     * This operation updates partially an Inventory entity.
     * @param inventorySkuOfferId Identifier of the Inventory
     * @param Inventory The Inventory to be updated
     */

    patchVisitBatches(
        id: string,
        body: VisitBatch,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling delete Inventory.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<any>> = this.httpClient.patch(
            `${this.APIConfiguration.basePath}/visits/batches/${id}`,
            body,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    // public listVisitBatches(
    //     fields?: string,
    //     offset?: number,
    //     limit?: number,
    //     observe: any = 'body',
    //     headers: Headers = {}
    // ): Observable<any> {
    //     headers.Accept = 'application/json;charset=utf-8';

    //     const response: Observable<HttpResponse<Array<VisitBatch>>> =
    //         this.httpClient.get(
    //             `${this.APIConfiguration.basePath}/visits/batches?` as any,
    //             headers
    //         );
    //     if (observe === 'body') {
    //         return response.pipe(map((httpResponse) => httpResponse.response));
    //     }
    //     return response;
    // }
    public listVisitBatches(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filters?: IFilter[],
        sort?: string
    ): Observable<any> {
        let queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                'fields=' + encodeURIComponent(String(fields))
            );
        }
        if (offset !== undefined) {
            queryParameters.push(
                'offset=' + encodeURIComponent(String(offset))
            );
        }
        if (limit !== undefined) {
            queryParameters.push('limit=' + encodeURIComponent(String(limit)));
        }
        if (sort) {
            queryParameters.push('sort=' + encodeURIComponent(String(sort)));
        }
        if (filters !== undefined) {
            filters.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}${
                        filter.operator === 'eq' ? '*=' : filter.operator
                    }${encodeURIComponent(String(filter.value))}`
                );
            });
        }

        headers['Accept'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<VisitBatch>>> =
            this.httpClient.get(
                `${
                    this.APIConfiguration.basePath
                }/visits/batches?${queryParameters.join('&')}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }
    public getAllZones(headers: Headers = {}): Observable<any> {
        headers.Accept = 'application/json;charset=utf-8';
        headers['x-auth-token'] =
            'VQ/ZK9+z2gzgTOm1ZnMyn0Ev6byXWPqWgsj1TrbN74c=';
        const response: Observable<HttpResponse<Array<Zones>>> =
            this.httpClient.get(
                `${this.APIConfiguration.geographicSiteUrl}/geographicSite?offset=0&limit=20&type=region`,
                headers
            );
        return response.pipe(map((d) => d.response));
    }
    public getAllHubs(
        type: string,
        id: string,
        headers: Headers = {}
    ): Observable<any> {
        headers.Accept = 'application/json;charset=utf-8';
        headers['x-auth-token'] =
            'VQ/ZK9+z2gzgTOm1ZnMyn0Ev6byXWPqWgsj1TrbN74c=';

        const response: Observable<HttpResponse<Array<Zones>>> =
            this.httpClient.get(
                `${this.APIConfiguration.geographicSiteUrl}/geographicSite?offset=0&limit=20&type=${type}&siteRelationship.id=${id}`,
                headers
            );
        console.log('type', response);
        return response.pipe(map((d) => d.response));
    }
}
