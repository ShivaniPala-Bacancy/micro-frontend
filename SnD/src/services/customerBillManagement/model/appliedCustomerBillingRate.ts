/**
 * API CustomerBill
 * ## TMF API Reference: TMF 678 - Customer bill Management  ### Release: 19.5 - December 2019  The Customer Bill Management API allows to find and retrieve one or several customer bills (also called invoices) produced for a customer. A customer bill is an electronic or paper document produced at the end of the billing process. The customer bill gathers and displays different items (applied customer billing rates generated during the rating and billing processes) to be charged to a customer. It represents a total amount due for all the products during the billing period and all significant information like dates, bill reference... This API provides also operations to find and retrieve the details of applied customer billing rates presented on a customer bill.  Finally, this API allows to request in real-time a customer bill creation and to manage this request.  ### Resources  - customerBill - appliedCustomerBillingRate - customerBillOnDemand - billingCycle  ### Operations Customer Bill Management API performs the following operations : - Retrieve a customer bill or a collection of customer bills depending on filter criteria. - Partial update of  a customer bill (for administration purposes). -  Retrieve an applied customer billing rate or a collection of applied customer billing rates depending on filter criteria. -  Create a customer bill on demand request, retrieve one or a collection of  customer bill on demand request(s) depending on filter criteria.  - Manage notification of events on customer bill and customer bill on demand.  Copyright Â© TM Forum 2018. All Rights Reserved.
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import { AppliedBillingRateCharacteristic } from './appliedBillingRateCharacteristic';
import { AppliedBillingTaxRate } from './appliedBillingTaxRate';
import { BillRef } from './billRef';
import { BillingAccountRef } from './billingAccountRef';
import { Money } from './money';
import { ProductRef } from './productRef';
import { TimePeriod } from './timePeriod';


/**
 * A customer bill displays applied billing rates created before or during the billing process.
 */
export interface AppliedCustomerBillingRate { 
    /**
     * Unique identifier of the customer applied billing rate
     */
    id: string;
    /**
     * Reference of the customer applied billing rate
     */
    href?: string;
    /**
     * Creation date of the applied billing rate
     */
    date?: Date;
    /**
     * Additional data to be displayed on the bill for this customer applied billing rate
     */
    description?: string;
    /**
     * If isBilled = true then bill should be provided, if false then billingAccount should be provided
     */
    isBilled?: boolean;
    /**
     * Name of the customer applied billing rate
     */
    name?: string;
    /**
     * Type of the applied billing rate : appliedBillingCharge (any kind of charge except taxation charges : recurringCharge, oneTimeCharge, usageCharge),  appliedBillingCredit (any kind of credit : rebate or productAlteration) or appliedPenaltyCharge (penalty charges such as late fees, payment rejection fees,...)
     */
    type?: string;
    appliedTax?: Array<AppliedBillingTaxRate>;
    bill?: BillRef;
    billingAccount?: BillingAccountRef;
    characteristic?: Array<AppliedBillingRateCharacteristic>;
    /**
     * periodCoverage for RecurringCharge (RC) indicating the RC coverage period dates for different purposes, such as RC proration, display on bill, GL reporting, etc. periodCoverage for OC start and end date will be the same
     */
    periodCoverage?: TimePeriod;
    /**
     * Usually this information should be provided by the PRODUCT, which implies that there is a valid reference to product. In this case, this property should be empty. For all other situations, a text or structured info could be provided using this property. Regular modelling would suggest tu use the reforvalue pattern for this case. It is not choosen here because it would generate declarational dependencies which would be hard to maintain.
     */
    product?: ProductRef;
    taxExcludedAmount?: Money;
    taxIncludedAmount?: Money;
    /**
     * When sub-classing, this defines the super-class
     */
    baseType?: string;
    /**
     * A URI to a JSON-Schema file that defines additional attributes and relationships
     */
    schemaLocation?: string;
    /**
     * When sub-classing, this defines the sub-class entity name
     */
    type?: string;
}
