/**
 * API GeographicLocation
 * ## TMF API Reference : TMF 675 - Geographic Location ### Release : 17.5 - January 2018  The geographic location API provides a standardized client interface to a location management system. A Geographic Location is a point, a surface or a volume defined by geographic point(s). These points should be associated with an accuracy and a spatial reference.  ### Resources - GeographicLocation - RetrieveGeographicLocation - RetrieveLocationRelation - Hub  ### Operations Geographic Location API performs the following operations : - Retrieve a geographic location or a collection of geographic locations - Retrieve a retrieve geographic location or a collection of retrieve geographic locations - Create a retrieve geographic location - Retrieve a retrieve location relation or a collection of retrieve location relations - Create a retrieve location relation - Notify events on these resources
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Observable} from 'rxjs';
import {map} from 'rxjs/operators';
import IHttpClient from '../../IHttpClient';
import {IAPIConfiguration} from '../../IAPIConfiguration';
import {Headers} from '../../Headers';
import HttpResponse from '../../HttpResponse';
import {GeographicLocation} from '../model/geographicLocation';
import HttpClient from '../../HttpClient';
import MasterConfigService from '../../master/api/MasterConfigService';
import IFilter from '../../../types/IFilter';

/* eslint-disable no-param-reassign */
export default class GeographicLocationService {
    APIConfiguration: IAPIConfiguration;

    masterService = new MasterConfigService();

    httpClient: IHttpClient;

    constructor() {
        this.APIConfiguration = {
            // basePath: isDevelopment() ? DEV_BASE_PATH : PROD_BASE_PATH
            basePath: ''
        };
        try {
            this.masterService
                .getServiceUrl('GEOGRAPHIC_LOCATION_URL')
                .subscribe((url) => (this.APIConfiguration.basePath = url));
        } catch (e) {
            console.log('error while fetching geographic location url', e);
        }
        this.httpClient = new HttpClient();
    }

    /**
     * Creates a new geographicLocation
     * 
     * @param geographicLocation 
     * @param fields Attribute selection
     
     */
    public geographicLocationCreateAndGetBody(
        geographicLocation: GeographicLocation,
        observe?: 'body',
        headers?: Headers
    ): Observable<GeographicLocation> {
        return this.geographicLocationCreate(
            geographicLocation,
            observe,
            headers
        );
    }

    public geographicLocationCreate(
        geographicLocation: GeographicLocation,
        fields?: any,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!geographicLocation) {
            throw new Error(
                'Required parameter geographic location was null or undefined when calling geographicLocationCreate.'
            );
        }
        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<GeographicLocation>> =
            this.httpClient.post(
                `${
                    this.APIConfiguration.basePath
                }/geographicLocation?${queryParameters.join('&')}`,
                geographicLocation as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * List geographic locations
     * This operation list geographic location entities. Attribute selection is enabled for all first level attributes.  Filtering may be available depending on the compliance level supported by an implementation.  Specific business errors for current operation will be encapsulated in  HTTP Response 422 Unprocessable entity 
     * @param fields Attribute selection
     * @param offset Requested index to start of resources to be provided in response requested by client
     * @param limit Requested number of resources to be provided in response requested by client
     
     */
    public geographicLocationFind(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'body',
        headers?: Headers,
        filters?: IFilter[]
    ): Observable<Array<GeographicLocation>>;

    public geographicLocationFind(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'response',
        headers?: Headers,
        filters?: IFilter[]
    ): Observable<HttpResponse<Array<GeographicLocation>>>;

    public geographicLocationFind(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filters?: IFilter[]
    ): Observable<any> {
        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }
        if (offset !== undefined) {
            queryParameters.push(
                `offset=${encodeURIComponent(String(offset))}`
            );
        }
        if (limit !== undefined) {
            queryParameters.push(`limit=${encodeURIComponent(String(limit))}`);
        }
        if (filters !== undefined) {
            // TODO
            filters.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}=${encodeURIComponent(String(filter.value))}`
                );
            });
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<GeographicLocation>>> =
            this.httpClient.get(
                `${
                    this.APIConfiguration.basePath
                }/geographicLocation?${queryParameters.join('&')}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Retrieve a geographic location
     * This operation retrieves a geographic location entity. Attribute selection is enabled for all first level attributes. Filtering on sub-resources may be available depending on the compliance level supported by an implementation.  Specific business errors for current operation will be encapsulated in  HTTP Response 422 Unprocessable entity 
     * @param geographicLocationId Unique identifier of the geographic location
     * @param fields Attribute selection
     
     */
    public geographicLocationGetBody(
        geographicLocationId: string,
        fields?: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<GeographicLocation> {
        return this.geographicLocationGet(
            geographicLocationId,
            fields,
            observe,
            headers
        );
    }

    public geographicLocationGet(
        geographicLocationId: string,
        fields?: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!geographicLocationId) {
            throw new Error(
                'Required parameter geographicLocationId was null or undefined when calling geographicLocationGet.'
            );
        }

        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<GeographicLocation>> =
            this.httpClient.get(
                `${
                    this.APIConfiguration.basePath
                }/geographicLocation/${encodeURIComponent(
                    String(geographicLocationId)
                )}?${queryParameters.join('&')}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Delete Geographic Location
     * 
     * @param geographicLocationId Unique identifier of the geographicLocation
     
     */
    public geographicLocationDeleteAndGetBody(
        geographicLocationId: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<any> {
        return this.geographicLocationDelete(
            geographicLocationId,
            observe,
            headers
        );
    }

    public geographicLocationDelete(
        geographicLocationId: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!geographicLocationId) {
            throw new Error(
                'Required parameter geographicLocationId was null or undefined when calling geographicLocationDelete.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(
            `${
                this.APIConfiguration.basePath
            }/geographicLocation/${encodeURIComponent(
                String(geographicLocationId)
            )}` as any,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Updates partially a ShippingOrder
     * This operation updates partially a ShippingOrder entity.
     * @param geographicLocationId Identifier of the geographicLocation
     * @param geographicLocation The geographicLocation to be updated
     
     */
    public patchShippingOrderAndGetBody(
        geographicLocationId: string,
        geographicLocation: GeographicLocation,
        observe?: 'body',
        headers?: Headers
    ): Observable<GeographicLocation> {
        return this.patchShippingOrder(
            geographicLocationId,
            geographicLocation,
            observe,
            headers
        );
    }

    public patchShippingOrder(
        geographicLocationId: string,
        geographicLocation: GeographicLocation,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!geographicLocationId) {
            throw new Error(
                'Required parameter geographicLocationId was null or undefined when calling patchShippingOrder.'
            );
        }

        if (!geographicLocation) {
            throw new Error(
                'Required parameter geographicLocation was null or undefined when calling patchShippingOrder.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<GeographicLocation>> =
            this.httpClient.patch(
                `${
                    this.APIConfiguration.basePath
                }/geographicLocation/${encodeURIComponent(
                    String(geographicLocationId)
                )}`,
                geographicLocation as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }
}
