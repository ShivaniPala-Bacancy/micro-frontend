/**
 * Product Ordering
 * **TMF API Reference : TMF 622 - Product Ordering Management**  **Release : 19.0 - June 2019**  The Product Ordering API provides a standardized mechanism for placing a product order with all of the necessary order parameters. The API consists of a simple set of operations that interact with CRM/Order Negotiation systems in a consistent manner. A product order is created based on a product offer that is defined in a catalog. The product offer identifies the product or set of products that are available to a customer, and includes characteristics such as pricing, product options and market. This API provide a task based resource to request order cancellation.  The product order references the product offer and identifies any specific requests made by the customer.  **Product Order resource** A Product Order is a type of order which can be used to place an order between a customer and a service provider or between a service provider and a partner and vice versa. Main Product Order attributes are its identifier, state, priority category (mass market, Enterprise, etc.) related dates (start, completion, etc.), related billing account, related parties and order items. Main Order Items (aka order lines) attributes are the ordered offering and product characteristics with the related action to be performed (e.g. add or delete the products), state, location information for delivery, order item price and price alteration.  Product Order API performs the following operations on product order :     -Retrieval of a product order or a collection of product orders depending on filter criteria     -Partial update of a product order (including updating rules)    -Creation of a product order (including default values and creation rules)    -Deletion of product order (for administration purposes)     -Notification of events on product order.  **cancelProductOrder resource** This resource is used to request a product order cancellation. Product Order API performs the following operations on product order :     -Retrieval of a cancel product order or a collection of cancel product orders     -Creation of a cancel product order     -Notification of events on cancel product order.   Copyright Â© TM Forum 2019. All Rights Reserved
 *
 * OpenAPI spec version: 4.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import IHttpClient from '../../IHttpClient';
import { IAPIConfiguration } from '../../IAPIConfiguration';
import { Headers } from '../../Headers';
import HttpResponse from '../../HttpResponse';
import { ProductOrder } from '../model/productOrder';
import { ProductOrderCreate } from '../model/productOrderCreate';
import HttpClient from '../../HttpClient';
import MasterConfigService from '../../master/api/MasterConfigService';
import IFilter from 'src/types/IFilter';

/* eslint-disable no-param-reassign */

export default class ProductOrderService {
    APIConfiguration: IAPIConfiguration;

    masterService = new MasterConfigService();

    httpClient: IHttpClient;

    constructor() {
        this.APIConfiguration = {
            // basePath: 'http://172.16.10.94:8888/api/v1/productordering'
            basePath: '',
            inventoryUrl: '',
            promotionsUrl: ''
        };
        try {
            this.masterService
                .getServiceUrl('PRODUCT_ORDER')
                .subscribe((url) => (this.APIConfiguration.basePath = url));
            this.masterService
                .getServiceUrl('INVENTORY_DETAILS_URL')
                .subscribe((url) => (this.APIConfiguration.inventoryUrl = url));
            this.masterService
                .getServiceUrl('PROMOTIONS_URL')
                .subscribe((url) => (this.APIConfiguration.promotionsUrl = url));
        } catch (e) {
            console.log('error while fetching product order url', e);
        }
        this.httpClient = new HttpClient();
    }

    /**
     * Creates a ProductOrder
     * This operation creates a ProductOrder entity.
     * @param productOrder The ProductOrder to be created
     
     */
    public createProductOrderAndGetBody(
        productOrder: ProductOrderCreate,
        observe?: 'body',
        headers?: Headers
    ): Observable<ProductOrder> {
        return this.createProductOrder(productOrder, observe, headers);
    }

    public createProductOrderAndGetResponse(
        productOrder: ProductOrderCreate,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<ProductOrder>> {
        return this.createProductOrder(productOrder, observe, headers);
    }

    public createProductOrder(
        productOrder: ProductOrder,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!productOrder) {
            throw new Error(
                'Required parameter productOrder was null or undefined when calling createProductOrder.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<ProductOrder>> =
            this.httpClient.post(
                `${this.APIConfiguration.basePath}`,
                productOrder as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Deletes a ProductOrder
     * This operation deletes a ProductOrder entity.
     * @param id Identifier of the ProductOrder
     
     */
    public deleteProductOrder(
        id: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<any>;

    public deleteProductOrder(
        id: string,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<any>>;

    public deleteProductOrder(
        id: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling deleteProductOrder.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(
            `${this.APIConfiguration.basePath
            }/productOrder/${encodeURIComponent(String(id))}` as any,
            headers
        );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * List or find ProductOrder objects
     * This operation list or find ProductOrder entities
     * @param fields Comma-separated properties to be provided in response
     * @param offset Requested index for start of resources to be provided in response
     * @param limit Requested number of resources to be provided in response
     
     */
    public listProductOrder(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'body',
        headers?: Headers,
        filters?: IFilter[]
    ): Observable<Array<ProductOrder>>;

    public listProductOrder(
        fields?: string,
        offset?: number,
        limit?: number,
        observe?: 'response',
        headers?: Headers,
        filters?: IFilter[]
    ): Observable<HttpResponse<Array<ProductOrder>>>;

    public listProductOrder(
        fields?: string,
        offset?: number,
        limit?: number,
        observe: any = 'body',
        headers: Headers = {},
        filters?: IFilter[]
    ): Observable<any> {
        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }
        if (filters !== undefined) {
            // TODO
            filters.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}=${encodeURIComponent(String(filter.value))}`
                );
            });
        }
        if (offset !== undefined) {
            queryParameters.push(
                `offset=${encodeURIComponent(String(offset))}`
            );
        }
        if (limit !== undefined) {
            queryParameters.push(`limit=${encodeURIComponent(String(limit))}`);
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<ProductOrder>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath}?${queryParameters.join(
                    '&'
                )}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public fetchProductOrder(
        id?: string,
        observe: any = 'body',
        headers: Headers = {},
        filters?: IFilter[]
    ): Observable<any> {
        const queryParameters: string[] = [];

        if (filters !== undefined) {
            // TODO
            filters.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}=${encodeURIComponent(String(filter.value))}`
                );
            });
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<ProductOrder>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath}/${id}?${queryParameters.join(
                    '&'
                )}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public generateInvoice(
        id?: string,
        observe: any = 'body',
        headers: Headers = {},
        filters?: IFilter[]
    ): Observable<any> {
        const queryParameters: string[] = [];

        if (filters !== undefined) {
            filters.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}=${encodeURIComponent(String(filter.value))}`
                );
            });
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<ProductOrder>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/invoice/${id}?${queryParameters.join('&')}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public getSiteLocation(
        siteId?: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        headers.Accept = 'application/json;charset=utf-8';
        headers['x-auth-token'] =
            'VQ/ZK9+z2gzgTOm1ZnMyn0Ev6byXWPqWgsj1TrbN74c=';
        const response: Observable<HttpResponse<any>> =
            this.httpClient.get(
                `http://172.16.10.94:9996/api/v1/geographicSiteManagement/geographicLocation/${siteId}`,
                headers
            );
        return response.pipe(map((d) => d.response));
    }

    /**
     * Updates partially a ProductOrder
     * This operation updates partially a ProductOrder entity.
     * @param id Identifier of the ProductOrder
     * @param productOrder The ProductOrder to be updated
     
     */
    public patchProductOrderAndGetBody(
        id: string,
        productOrder: ProductOrder,
        observe?: 'body',
        headers?: Headers
    ): Observable<ProductOrder> {
        return this.patchProductOrder(id, productOrder, observe, headers);
    }

    public patchProductOrderAndGetResponse(
        id: string,
        productOrder: ProductOrder,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<ProductOrder>> {
        return this.patchProductOrder(id, productOrder, observe, headers);
    }

    public patchProductOrder(
        id: string,
        productOrder: any,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!productOrder) {
            throw new Error(
                'Required parameter productOrder was null or undefined when calling patchProductOrder.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['Content-Type'] = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<ProductOrder>> =
            this.httpClient.patch(
                `${this.APIConfiguration.basePath
                }/mergepatch/${encodeURIComponent(String(id))}`,
                productOrder,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    /**
     * Retrieves a ProductOrder by ID
     * This operation retrieves a ProductOrder entity. Attribute selection is enabled for all first level attributes.
     * @param id Identifier of the ProductOrder
     * @param fields Comma-separated properties to provide in response
     
     */
    public retrieveProductOrder(
        id: string,
        fields?: string,
        observe?: 'body',
        headers?: Headers
    ): Observable<ProductOrder>;

    public retrieveProductOrder(
        id: string,
        fields?: string,
        observe?: 'response',
        headers?: Headers
    ): Observable<HttpResponse<ProductOrder>>;

    public retrieveProductOrder(
        id: string,
        fields?: string,
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        if (!id) {
            throw new Error(
                'Required parameter id was null or undefined when calling retrieveProductOrder.'
            );
        }

        const queryParameters: string[] = [];
        if (fields !== undefined) {
            queryParameters.push(
                `fields=${encodeURIComponent(String(fields))}`
            );
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<ProductOrder>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath
                }/productOrder/${encodeURIComponent(
                    String(id)
                )}?${queryParameters.join('&')}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public retrievePromotions(
        observe: any = 'body',
        headers: Headers = {}
    ): Observable<any> {
        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<ProductOrder>> =
            this.httpClient.get(
                `${this.APIConfiguration.promotionsUrl}/0` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }

    public stockStatusCheck(body: any, headers: Headers = {}): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createInventory.'
            );
        }

        headers.Accept = 'application/json;charset=utf-8';
        headers['x-auth-token'] =
            'VQ/ZK9+z2gzgTOm1ZnMyn0Ev6byXWPqWgsj1TrbN74c=';
        const response: Observable<HttpResponse<any>> = this.httpClient.post(
            `${this.APIConfiguration.inventoryUrl}/inventorymanagement/productOrder/stock/status`,
            body,
            headers
        );
        return response.pipe(map((d) => d.response));
    }

    public fetchProductOrderBasedOnOrderId(
        id?: string,
        observe: any = 'body',
        headers: Headers = {},
        filters?: IFilter[]
    ): Observable<any> {
        const queryParameters: string[] = [];

        if (filters !== undefined) {
            // TODO
            filters.forEach((filter: IFilter) => {
                queryParameters.push(
                    `${filter.key}=${encodeURIComponent(String(filter.value))}`
                );
            });
        }

        headers.Accept = 'application/json;charset=utf-8';

        const response: Observable<HttpResponse<Array<ProductOrder>>> =
            this.httpClient.get(
                `${this.APIConfiguration.basePath}?orderId=${id}` as any,
                headers
            );
        if (observe === 'body') {
            return response.pipe(map((httpResponse) => httpResponse.response));
        }
        return response;
    }
}
